class Scenario
{
// Private:
	var FloorMesh, FloorObj;
	var FloorMaterial, FloorTexture;
	var WallMesh, WallObj;
	var WallMaterial, WallTexture;
	var Walls;
	
// Public:
	var Width;
	var Height;
	
	var Player;
	var Enemies;

	Init(filename);
	Update();
	Draw();
	
	AddEnemy(p);
	
	IsColliding(x, z, radius);
};


function distance(p1, p2)
{
	return modulus(p1.x_z - p2.x_z);
}


function Scenario::Init(filename)
{
	/* Load scenario file */
	var data = LoadFile(filename);
	Height = len(data) - 1;
	Width = len(data[0]);
	
	/* Initialize enemies */
	Enemies = Array(0);
	
	/* Initialize wall data structure */
	Walls = array(height);
	for (var i = 0; i < height; i++)
		Walls[i] = array(width);
	
	/* Initialize materials */
	WallMaterial  = CVmMaterial();
	FloorMaterial = CVmMaterial();
	WallTexture  = CVmTexture("Mattoni03.png");
	FloorTexture = CVmTexture("Marmostriato2.png");
	
	WallMaterial.Diffuse = [1, 1, 1];
	WallMaterial.SetTexture(WallTexture);
	FloorMaterial.Diffuse = [1, 1, 1];
	FloorMaterial.SetTexture(FloorTexture);
	WallMaterial.ChangeTextureParams(VR_V_TILING, 3);
	
	/* Initialize meshes */
	WallMesh = CVmNewMesh(VRP_BOX);
	FloorMesh = CVmNewMesh(VRP_BOX);
	
	/* Position floor */
	FloorMesh.Translate(0, -1,  0);
	FloorMesh.Scale(width, 1, height);
	
	/* Apply materials */
	WallMesh.Scale(1, 3, 1);
	WallMesh.ForceMaterial(WallMaterial);
	FloorMesh.ForceMaterial(FloorMaterial);
	FloorMesh.ModulateMaterials(0, 1, 0, 1);
	
	/* Initialize objects */
	WallObj = array(0);
	FloorObj = CVmObj(FloorMesh);
	
	/* Parse level file */
	for(var i = 0; i < height; i++)
		for (var j = 0; j < width; j++)
		{
			if(data[i][j] == "*")
			{
				/* Add wall piece */
				var wall = CVmObj();
				wall.LinkToMesh(WallMesh);
				wall.SetPosition(j, 0, i);
				aadd(WallObj, wall);
				Walls[i][j] = 1;
			} 
			else
				Walls[i][j] = 0;
		}
}


function Scenario::Draw()
{
	/* Draw floor */
	FloorObj.Draw();
	
	/* Draw walls */
	foreach (var w in WallObj)
		w.Draw();
		
	/* Draw player */
	Player.Draw();
		
	/* Draw enemies */
	foreach (var e in Enemies)
		e.Draw();
}


function Scenario::AddEnemy(p)
{
	aadd(Enemies, p);
}


function Scenario::Update()
{
	Player.Update(this);
	
	foreach (var e in Enemies)
		e.Update(this);
	
	foreach (var e in Enemies)
		foreach (var b in Player.Bullets)
			if(distance(e.Position, b.Position) < 0.3)
			{
				b.IsFlying = false;
				Player.Scored();
				e.Hit();
				outputln("Player ", Player.ID, " hit Player ", e.ID);
			}
	
//	foreach (var p in Players)
//	{
//		foreach ( var b in p.Bullets)
//		{
//			if(b.IsFlying)
//			{
//				foreach (var q in Players)
//				{
//					if(p != q)
//					{
//						if(distance(q.Position, b.Position) < 0.3)
//						{
//							b.IsFlying = false;
//							p.Scored();
//							q.Hit();
//							outputln("Player ", p.ID, " hit Player ", q.ID);
//						}
//					}
//				}
//			}
//		}
//	}
}

function Scenario::IsColliding(x, z, radius)
{
	var center = [x, 0, z];
	
	var a = [int(center.x + radius), 0, int(center.z + radius)];
	var b = [int(center.x - radius), 0, int(center.z + radius)];
	var c = [int(center.x - radius), 0, int(center.z - radius)];
	var d = [int(center.x + radius), 0, int(center.z - radius)];
	
	if (Walls[a.z][a.x] == 1 ||
		Walls[b.z][b.x] == 1 ||
		Walls[c.z][c.x] == 1 ||
		Walls[d.z][d.x] == 1)
		return true;
	else
		return false;
}
