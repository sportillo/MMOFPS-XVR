#include <Weapon.s3d>
#include <Network.s3d>

SET WEAPON_INTERVAL = 5000;

class Scenario
{
// Private:
	var FloorMesh, FloorObj;
	var FloorMaterial, FloorTexture;
	var WallMesh, WallObj;
	var WallMaterial, WallTexture;
	var Walls;
	
	var WeaponSpawns;
	var WeaponCount;
	var WeaponTimer;
	
	var ScoreTimer;
	
// Public:
	var Width;
	var Height;
	
	var Player;
	var Enemies;

	Init(filename);
	Update();
	Draw();
	
	AddEnemy(p);
	GetById(pid);
	UpdateFX(listener);
	
	IsColliding(x, z, radius);
	ExistID(pid);
};


function distance(p1, p2)
{
	return modulus(p1.x_z - p2.x_z);
}


function Scenario::Init(filename)
{
	/* Load scenario file */
	var data = LoadFile(filename);
	Height = len(data) - 1;
	Width = len(data[0]);
	
	/* Initialize enemies */
	Enemies = Array(0);
	
	/* Initialize spawns */
	WeaponSpawns = Array(0);
	WeaponTimer  = 0;
	WeaponCount  = 0;
	
	/* Initialize timers */
	ScoreTimer = 0;
	
	/* Initialize wall data structure */
	Walls = array(height);
	for (var i = 0; i < height; i++)
		Walls[i] = array(width);
	
	/* Initialize materials */
	WallMaterial  = CVmMaterial();
	FloorMaterial = CVmMaterial();
	WallTexture  = CVmTexture("Mattoni03.png");
	FloorTexture = CVmTexture("Marmostriato2.png");
	
	WallMaterial.Diffuse = [1, 1, 1];
	WallMaterial.SetTexture(WallTexture);
	FloorMaterial.Diffuse = [1, 1, 1];
	FloorMaterial.SetTexture(FloorTexture);
	WallMaterial.ChangeTextureParams(VR_V_TILING, 3);
	
	/* Initialize meshes */
	WallMesh = CVmNewMesh(VRP_BOX);
	FloorMesh = CVmNewMesh(VRP_BOX);
	
	/* Position floor */
	FloorMesh.Translate(0, -1,  0);
	FloorMesh.Scale(width, 1, height);
	
	/* Apply materials */
	WallMesh.Scale(1, 3, 1);
	WallMesh.ForceMaterial(WallMaterial);
	FloorMesh.ForceMaterial(FloorMaterial);
	FloorMesh.ModulateMaterials(0, 1, 0, 1);
	
	/* Initialize objects */
	WallObj = array(0);
	FloorObj = CVmObj(FloorMesh);
	
	/* Parse level file */
	for (var i = 0; i < height; i++)
		for (var j = 0; j < width; j++)
		{
			if (data[i][j] == "*")
			{
				Walls[i][j] = 1;
				
				/* Add wall piece */
				var wall = CVmObj();
				wall.LinkToMesh(WallMesh);
				wall.SetPosition(j, 0, i);
				aadd(WallObj, wall);
			}
			else
			{
				Walls[i][j] = 0;
				
				if (data[i][j] == "W")
					aadd(WeaponSpawns, {[j + 0.5, 0, i + 0.5], null});					
			}
		}
}


function Scenario::Draw()
{
	/* Draw floor */
	FloorObj.Draw();
	
	/* Draw walls */
	foreach (var w in WallObj)
		w.Draw();
		
	/* Draw player */
	Player.Draw();
		
	/* Draw enemies */
	foreach (var e in Enemies)
		e.Draw();
		
	/* Draw spawns */
	foreach (var s in WeaponSpawns)
		if (s[1] != null)
			s[1].Draw();
}


function Scenario::AddEnemy(p)
{
	p.Level = this;
	aadd(Enemies, p);
}


function Scenario::UpdateFX(listener)
{
	Player.UpdateFX(listener);
	
	foreach (var e in Enemies)
		e.UpdateFX(listener);
}


function Scenario::Update()
{
	/* Receive network updates */
	var more = true;
	while (more)
	{
		var data = NetworkRecv();
		
		if (data != void)
		{
			if (data[1] != Player.ID)
			{
				if (data[0] == ADVERTISE_PDU)
				{
					var enemy = GetById(data[1]);
					
					/* New player */
					if (enemy == void)
					{
						OutputLN("Player " + str(data[1]) + " connected.");
						AddEnemy(Swat(data[1], [data[2], data[3], data[4]], [0,0,0], false));
						enemy = GetByID(data[1]);
					}
					
					enemy.AdvertiseTimer = getTime();
				}
				else if (data[0] == MOVEMENT_PDU)
				{
					var enemy = GetById(data[1]);
					
					if (enemy != void)
					{
						enemy.Position = [data[2], data[3], data[4]];
						enemy.Pitch    = data[5];
						enemy.Yaw      = data[6];
						
						if (data[7] == 0)
							enemy.IsMoving = false;
						else
							enemy.IsMoving = true;
							
						enemy.CurrentFrame = data[8];
					}
				}
				else if (data[0] == SCORE_PDU)
				{
					var num = len(data) - 2;
					
					for (var i = 2; i < num; i += 2)
					{
						var e = GetById(data[i]);
						
						if (e != void && e.Score < data[i+1])
							e.Score = data[i+1];
					}
				}
				else if (data[0] == BULLETS_PDU)
				{
					var e   = GetById(data[1]);
					var num = (len(data) - 2) / 6;
					
					asize(e.Bullets, num);
					
					for (var i = 2, j = 0; i < (num * 6); i += 6, j++)
					{
						e.Bullets[j].Position.x  = data[i + 0];
						e.Bullets[j].Position.y  = data[i + 1];
						e.Bullets[j].Position.z  = data[i + 2];
						e.Bullets[j].Direction.x = data[i + 3];
						e.Bullets[j].Direction.y = data[i + 4];
						e.Bullets[j].Direction.z = data[i + 5];
					}
				}
			}
		}
		else
		{
			more = false;
		}
	}
	
	/* Update player */
	Player.Update(this);
	
	/* Update enemies */
	for (var i = 0; i < len(Enemies); i++)
	{
		var e = Enemies[i];
		
		if (getTime() - e.AdvertiseTimer > PLAYER_TIMEOUT)
		{
			OutputLN("Player " + str(e.ID) + " disconnected.");
			adel(Enemies, i);
			i--;
		}
		else
			e.Update(this);
	}
		
	/* Check new spawns and update */
	if (getTime() - WeaponTimer > WEAPON_INTERVAL)
	{
		WeaponTimer = getTime();
		
		var numSpawns = len(WeaponSpawns);
		if (WeaponCount < numSpawns)
		{
			static var loc = 0;
			
			if (WeaponSpawns[loc][1] == null)
			{
				var w = Weapon("railgun.aam", true);
				w.SetSpawn(WeaponSpawns[loc][0]);
			
				WeaponCount++;
				WeaponSpawns[loc][1] = w;	
			}
			
			loc = (loc + 1) % numSpawns;
		}
	}
	
	for (var i = 0; i < len(WeaponSpawns); i++)
	{
		if (WeaponSpawns[i][1] != null)
			WeaponSpawns[i][1].Update();
	}
	
	/* Check player collision */
	foreach (var b in Player.Bullets)
		foreach (var e in Enemies)
			if(distance(e.Position.x_z, b.Position.x_z) < 0.5 && b.Position.y < 1.8)
			{
				b.IsFlying = false;
				
				var kill = e.Hit();
				if (kill)
					Player.Scored();
			}
			
	/* Send scores */
	if (getTime() - ScoreTimer > SCORE_TIMEOUT)
	{
		scoreTimer = getTime();
		
		var PDU = Vector((len(Enemies) * 2) + 4);
		PDU[0] = SCORE_PDU;
		PDU[1] = Player.ID;
		PDU[2] = Player.ID;
		PDU[3] = Player.Score;
		
		var i = 4;
		foreach (var e in Enemies)
		{
			PDU[i]   = e.ID;
			PDU[i+1] = e.Score;
			i += 2;
		}
		
		NetworkSend(PDU);
	}
}

function Scenario::IsColliding(x, z, radius)
{
	var center = [x, 0, z];
	
	var a = [int(center.x + radius), 0, int(center.z + radius)];
	var b = [int(center.x - radius), 0, int(center.z + radius)];
	var c = [int(center.x - radius), 0, int(center.z - radius)];
	var d = [int(center.x + radius), 0, int(center.z - radius)];
	
	if (Walls[a.z][a.x] == 1 ||
		Walls[b.z][b.x] == 1 ||
		Walls[c.z][c.x] == 1 ||
		Walls[d.z][d.x] == 1)
		return true;
	else
		return false;
}

function Scenario::ExistID(pid)
{
	foreach (var e in Enemies)
		if (e.ID == pid)
			return true;
			
	return false;
}

function Scenario::GetById(pid)
{
	foreach (var e in Enemies)
		if (e.ID == pid)
			return e;
			
	return void;
}
